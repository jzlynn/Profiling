<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <script type="text/javascript" src="echarts.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
    <h1 id="page-caption" style="margin: 2em 0 2em 0; text-align: center;">PerfAI</h1>
    <div class="tabs" id="tabs"></div>
    <div id="tab-container"></div>
    <div id="content-container"></div>

    <!-- 总表 -->
    <div id="summary-table"></div>
    <div id="msg-container"></div>

    <!-- 分表 -->
    <div id="custom-tooltip" style="display: none; position: absolute; background: #fff; border: 1px solid #000; padding: 10px;"></div>

    <div id="config-container">
        <div class="config-item"><input type="checkbox" id="show_data_table" value="Show data" />Show data</div>
        <div class="config-item config-localmem"><input type="checkbox" id="show_localmem" value="Show localmem" />Show localmem</div>
        <div class="config-item"><input type="checkbox" id="tiu_uarch_rate" value="TIU uArch Rate" />TIU uArch Rate</div>
    </div>
    <div id="data-list"></div>
    <hr>
    <div id="lmem-container" class="mem-container" style="display: none;"></div>
    <hr>
    <div id="rate-line-container"></div>
    <hr>
    <div id="pie-chart-container">
        <div id="chart1" class="chart"></div>
        <div id="chart2" class="chart"></div>
        <div id="chart3" class="chart"></div>
    </div>

    <style>
        .tabs {
            margin: 10 auto;
        }
        
        .tabs .tab {
            width: 75px;
            height: 32px;
            padding: 10px 20px;
            margin: 0 10px 20px;
            display: inline-block;
            text-align: center;
            line-height: 32px;
            text-align: center;
            color: #fff;
            background-color: #223668;
            border-color: #d87c04;
            border-radius: 5px;
            white-space: nowrap;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
        }
        
        .bg-r {
            background-color: red!important;
            color: #fff!important;
        }
        
        .tabs div:hover {
            background-color: red;
            color: #fff;
        }
        
        #msg-container {
            width: 95%;
            height: 800px;
            margin: 80px auto;
            border: 1px solid #ccc;
            padding: 1em 1em;
        }
        
        #time-container2,
        #time-container3,
        #time-container4,
        #time-container5,
        #time-container6,
        #time-container7,
        #time-container8 {
            display: none;
        }
        
        #config-container {
            margin-left: 0;
            margin-top: 1em;
        }
        
        .config-item {
            display: inline-block;
            padding-left: 2em;
        }
        
        body {
            text-align: center;
        }
        
        .mem-container {
            height: 800px;
            width: 90%;
            padding-left: 2%;
        }
        
        #data-list {
            display: none;
            height: 600px;
            overflow-y: auto;
            /* Enables vertical scrolling */
            width: 90%;
            margin-left: 5%;
        }
        
        td,
        th {
            padding: 0;
        }
        
        .data-table {
            border-collapse: collapse;
            border-spacing: 0;
            empty-cells: show;
            border: 1px solid #cbcbcb;
            width: 90%;
            margin-left: 5%;
        }
        
        .data-table caption {
            color: #000;
            font: bold, arial, sans-serif;
            font-size: larger;
            padding: 0.5em 0;
            text-align: center;
        }
        
        .data-table thead td.asc:after {
            content: "↑"
        }
        
        .data-table thead td.desc::after {
            content: "↓"
        }
        
        .filter-label::after {
            content: ": "
        }
        
        .filter-block {
            display: inline;
            margin-right: 1em;
        }
        
        .data-table thead td:hover {
            cursor: pointer;
        }
        
        .data-table td,
        .data-table th {
            border-left: 1px solid #cbcbcb;
            border-top: 1px solid #cbcbcb;
            font-size: inherit;
            margin: 0;
            overflow: visible;
            padding: .5em 1em;
        }
        
        .data-table tbody tr:hover {
            background-color: aliceblue;
        }
        
        .data-table thead {
            background-color: #e0e0e0;
            color: #000;
            text-align: left;
            vertical-align: bottom;
        }
        
        .data-table td {
            background-color: transparent;
        }
        
        .data-table-odd td {
            background-color: #f2f2f2;
        }
        
        hr {
            margin: 2em 0 2em 0;
            color: gray;
        }
        
        #pie-chart-container {
            display: flex;
            justify-content: space-between;
            width: 80%;
            height: 500px;
            margin: 0 auto;
        }
        
        .chart {
            flex: 1;
            height: 100%;
        }
        
        #rate-line-container {
            width: 90%;
            height: 500px;
            padding-left: 4%
        }
    </style>
    <script type="text/javascript" src="profile_data_test1.js"></script>
    <script>
        var cycleData = {};
        var lmemData = {};

        function generateTabs() {;
            for (var i = 1; i <= Object.keys(window).filter(key => key.startsWith('time_data')).length; i++) {
                cycleData[i] = window['time_data' + i]
                lmemData[i] = window['lmem_op_record' + i];

                //create tab page based on the dataset
                var tabId = 'tab' + i;
                var tabContentId = 'tab-content' + i;
                var newTab = $('<div class="tab">Core' + i + '</div>');
                var newTabContent = $('<div id="' + tabContentId + '"></div>').appendTo('#tab-content');;
                var timeContainerId = 'time-container' + i;
                var newTimeContainer = $('<div id="' + timeContainerId + '"></div>').appendTo('#content-container');

            }
            // Trigger click on the first tab
            $('.tab').first().click();
        }


        $(document).ready(function() {
            generateTabs();
            //console.log("cycledata:", cycleData)
            //console.log("lmemData:", lmemData)
        });
    </script>
    <script>
        echarts.debugMode = true;
        console.log("cycledata:", cycleData)
        var all_charts = []
        var filtered_data = []

        function set_chart_time_range(begin_usec, end_usec, source) {
            for (let c of all_charts) {
                if (c === source) continue
                if (c && c.set_time_range) c.set_time_range(begin_usec, end_usec)
            }
        }
    </script>
    <script>
        function sortData(data, is_asc) {
            index = []
            for (let i = 0; i < data.length; i++) {
                index.push(i)
            }
            for (let i = data.length; i > 0; i--) {
                let is_swaped = false
                for (let j = 0; j < i - 1; j++) {
                    if ((data[j] > data[j + 1] && is_asc) || (data[j] < data[j + 1] && !is_asc)) {
                        is_swaped = true
                        let tmp = data[j + 1]
                        data[j + 1] = data[j]
                        data[j] = tmp
                        tmp = index[j + 1]
                        index[j + 1] = index[j]
                        index[j] = tmp
                    }
                }
                if (!is_swaped) break;
            }
            return index
        }

        function sortDataByColumn(data, col, is_asc) {
            let key_data = []
            for (let i = 0; i < data.length; i++) {
                key_data.push(data[i][col])
            }
            let index = sortData(key_data, is_asc)

            let new_data = []
            for (let i = 0; i < index.length; i++) {
                new_data.push(data[index[i]])
            }
            return new_data
        }

        function sortTableByColumn(e, data, usec_cols) {
            let col_head = e.target;
            let index = parseInt(col_head.className.split("-")[1])
            let is_asc = !(col_head.classList.contains("asc") || col_head.classList.length == 1)
            let all_heads = col_head.parentNode.children
            for (let h of all_heads) {
                h.classList.remove("asc")
                h.classList.remove("desc")
            }
            col_head.classList.add(is_asc ? "asc" : "desc")
            let row_elems = col_head.parentNode.parentNode.parentNode.lastChild.children
            if (typeof(data) === "undefined") {
                data = []
                for (let r = 0; r < row_elems.length; r++) {
                    let row_data = []
                    let col_elems = row_elems[r].children
                    for (let c = 0; c < col_elems.length; c++) {
                        let value = col_elems[c].innerText
                        if (all_heads[c].getAttribute("type") == "number") {
                            value = Number(value)
                        }
                        row_data.push(value)
                    }
                    data.push(row_data)
                }
            }
            sorted_data = sortDataByColumn(data, index, is_asc)
            if (typeof(usec_cols) == "undefined") {
                usec_cols = []
            }
            for (let r = 0; r < row_elems.length; r++) {
                let row_data = sorted_data[r]
                if (usec_cols.length > 0) {
                    row_elems[r].onclick = (e) => {
                        set_chart_time_range(row_data[usec_cols[0]], row_data[usec_cols[1]])
                    }
                }
                let col_elems = row_elems[r].children
                for (let c = 0; c < col_elems.length; c++) {
                    if (usec_cols.indexOf(c) >= 0) {
                        col_elems[c].innerHTML = usec_str(row_data[c])
                    } else {
                        col_elems[c].innerHTML = row_data[c]
                    }
                }
            }
        }

        function showDataTable(id, header, data, caption) {
            let node = document.getElementById(id)
            if (!node) return;
            let table = document.createElement("table")
            table.id = `table-${id}`
            table.className = "data-table"
            if (caption) {
                let capNode = table.createCaption()
                capNode.innerText = caption
            }
            let head = table.createTHead()
            let row = document.createElement("tr")
            head.appendChild(row)
            for (let i = 0; i < header.length; i++) {
                let col = document.createElement("td")
                col.innerText = header[i]
                col.className = `header-${i}`
                if (data.length > 0) {
                    col.setAttribute("type", typeof(data[0][i]))
                }
                col.onclick = sortTableByColumn
                row.appendChild(col)
            }
            let body = table.createTBody()
            for (let r = 0; r < data.length; r++) {
                let row_data = data[r]
                let row_body = document.createElement("tr")
                body.appendChild(row_body)
                for (let c = 0; c < row_data.length; c++) {
                    let col_body = document.createElement("td")
                    col_body.innerText = row_data[c]
                    row_body.appendChild(col_body)
                    if (r === data.length - 1) {
                        col_body.style.backgroundColor = "yellow";
                    }
                }
            }
            node.appendChild(table)
        }

        function createMsgChart(dataGroups, categories) {
            let data = [];
            let yAxisLabels = [];
            let header = ["Msg", 'beginTime', 'endTime', 'duration', 'height', 'cmd', 'msgId', 'sdWtCount']
                // Iterate through dataset and filter out send/wait msgs
            for (let idx in dataGroups) {
                ['WAIT', 'SEND'].forEach(type => {
                    let category = `Core${idx} ${type}`;
                    yAxisLabels.push(category);
                });
                dataGroups[idx].forEach(row => {
                    let msgId = row[7];
                    if (msgId) {
                        let engine = categories[row[0]]
                        let beginTime = row[1];
                        let endTime = row[2];
                        let duration = endTime - beginTime;
                        let cmd = row[5];
                        let funcName = row[6];
                        let sdWtCount = row[8];
                        const msgType = funcName.includes('send') ? 'SEND' : funcName.includes('wait') ? 'WAIT' : '';
                        if (msgType !== '') {
                            msgTypeIndex = yAxisLabels.indexOf(`Core${idx} ${msgType}`);
                        }
                        data.push([msgTypeIndex, beginTime, endTime, duration, -1, cmd, msgId, sdWtCount, engine]);
                    }
                });
            }
            console.log("data:", data)
                //console.log("yAxislabel:", yAxisLabels)
            let chart = echarts.init(document.getElementById('msg-container'));
            let color_col = 6;
            let msg_data = []
            let category_time = []
            let category_count = []
            for (let i = 0; i < yAxisLabels.length; i++) {
                category_time.push(0)
                category_count.push(0)
            }
            let startTime = data.length > 0 ? data[0][1] : 0;
            for (let i = 0; i < data.length; i++) {
                if (startTime > data[i][1]) startTime = data[i][1];
                category_time[data[i][0]] += data[i][2] - data[i][1];
                category_count[data[i][0]] += 1;
                let colorPalette = colors[calcColorIndex(data[i][color_col], colors.length)];
                console.log("colorPalette:", colorPalette)
                msg_data.push({
                    name: `${data[i][3]}`,
                    value: data[i],
                    itemStyle: {
                        normal: {
                            opacity: 0.8,
                            color: colorPalette,
                            // borderColor: "#FFFFFF",
                        }
                    }
                })
            }
            console.log("msg_data:", msg_data)
            let new_categories = [];
            for (let i = 0; i < yAxisLabels.length; i++) {
                new_categories.push(yAxisLabels[i] +
                    "\ncount=" + category_count[i]
                )
            }
            let option = {
                title: {
                    text: 'Msg Time Chart',
                    fontSize: 20,
                    left: 'center',
                },
                tooltip: {
                    alwaysShowContent: true,
                    position: function(pos, params, el, elRect, size) {
                        var obj = {
                            top: pos[1] - 30
                        };
                        if (pos[0] + size.contentSize[0] > size.viewSize[0]) {
                            obj['left'] = size.viewSize[0] - size.contentSize[0];
                        } else {
                            obj['left'] = pos[0];
                        }
                        return obj;
                    },
                    formatter: function(params) {
                        let tip = `Msg_Id: ${params.value[6]}<br>Engine: ${params.value[8]}<br>Sd/Wt Count: ${params.value[7]}<br>begin: ${usec_str(params.value[1])}<br>end: ${usec_str(params.value[2])}<br>duration: ${usec_str(params.value[3])}`
                        return tip;
                    },
                    axisPointer: {
                        show: true,
                        type: 'cross',
                        lineStyle: {
                            type: 'dashed',
                            width: 1
                        },
                        label: {
                            show: true,
                            formatter: function(param) {
                                if (param.axisDimension == 'x') {
                                    return usec_str(param.value)
                                }
                                return param.value
                            }
                        }
                    }
                },
                dataZoom: [{
                    type: 'slider',
                    filterMode: 'weakFilter',
                    showDataShadow: false,
                    height: 10,
                    borderColor: 'transparent',
                    backgroundColor: '#e2e2e2',
                    handleIcon: 'M10.7,11.9H9.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line
                    handleSize: 20,
                    handleStyle: {
                        shadowBlur: 6,
                        shadowOffsetX: 1,
                        shadowOffsetY: 2,
                        shadowColor: '#aaa'
                    },
                    bottom: 40,
                    realtime: true,
                    labelFormatter: ''
                }, {
                    type: 'inside',
                    realtime: true,
                    filterMode: 'weakFilter'
                }],
                grid: {
                    height: 300
                },
                grid: {
                    height: 600,
                    bottom: 40,
                    top: 80
                },
                xAxis: {
                    min: startTime,
                    scale: true,
                    axisLabel: {
                        formatter: function(val) {
                            return (val);
                        }
                    },
                },
                yAxis: {
                    data: new_categories

                },
                toolbox: {
                    right: '10%',
                    feature: {
                        dataZoom: {
                            yAxisIndex: 'none'
                        },
                        restore: {},
                        saveAsImage: {},
                    }
                },
                series: [{
                    type: 'custom',
                    renderItem: renderItem,
                    encode: {
                        x: [1, 2],
                        y: 0
                    },
                    data: msg_data,
                }]
            };
            let originalOption = JSON.parse(JSON.stringify(option));
            if (option && typeof option === "object") {
                chart.setOption(option, true);
            }

            let originalItemStyles = msg_data.map(item => item.itemStyle);
            chart.on('mouseover', function(params) {
                if (params.data) {
                    let msgId = params.data.value[6];
                    let option = JSON.parse(JSON.stringify(originalOption)); //make the deepcopy
                    option.series[0].data.forEach((item, index) => {
                        if (item.value[6] === msgId) {
                            item.itemStyle = {
                                normal: {
                                    color: item.itemStyle.color,
                                    opacity: 1
                                }
                            }; //highlight
                        } else {
                            item.itemStyle = {
                                normal: {
                                    color: item.itemStyle.color,
                                    opacity: 0.2
                                }
                            }; //faint others
                        }
                    });
                    chart.setOption(option);
                }
            });

            chart.on('mouseout', function() {
                let option = JSON.parse(JSON.stringify(originalOption));
                option.series[0].data.forEach((item, index) => {
                    item.itemStyle = originalItemStyles[index]; // Restore original itemStyle
                });
                chart.setOption(option);
            });
        }
    </script>
    <script type="text/javascript">
        function usec_str(u) { //删去了后缀cycle单位
            if (u < 1000) { //u.toFixed()
                return `${u.toFixed(0)}`
            } else if (u < 1000000) {
                return `${u.toFixed(0)}`
            } else { //if(u<10000000000000000) {
                return `${(u.toFixed(0))}`
            }
        }

        function renderItem(params, api) {
            if (!api.value || !api.value.length) return false
            let categoryIndex = api.value(0);
            let start = api.coord([api.value(1), categoryIndex]);
            let end = api.coord([api.value(2), categoryIndex]);
            let height_value = api.value(4)
            if (height_value < 0) {
                height_value = 1
            }
            let ratio = 0.6
            let bottom_height = api.size([0, 1])[1] * ratio;
            let r = 2
            let min_width = 5
            let min_height = 5
            let h = min_height + (bottom_height - min_height) * height_value
            let w = Math.max(end[0] - start[0], min_width)
            let x = start[0]
            let y = start[1] + bottom_height / 2 - h
            let points = [
                [x + r, y],
                [x + w - r, y],
                [x + w, y + r],
                [x + w, y + h - r],
                [x + w - r, y + h],
                [x + r, y + h],
                [x, y + h - r],
                [x, y + r]
            ];
            params.context.rendered = true;

            let tip = api.value(6) + '\n' + usec_str(api.value(2) - api.value(1))
            var tipRect = echarts.format.getTextRect(tip);
            if (tipRect.width > w) {
                tip = ""
            }
            let textY = y + 1
            let textColor = "white"
            if (tipRect.height > h) {
                textY = y - tipRect.height - 2
                textColor = "black"
            }
            let textRect = echarts.graphic.clipRectByRect({
                x: x,
                y: textY,
                width: w,
                height: tipRect.height,
            }, params.coordSys);
            let item = {
                type: 'group',
                children: [{
                    type: 'polygon',
                    shape: {
                        points: echarts.graphic.clipPointsByRect(points, {
                            x: params.coordSys.x,
                            y: params.coordSys.y,
                            width: params.coordSys.width,
                            height: params.coordSys.height
                        })
                    },
                    style: api.style({})
                }, {
                    type: "rect",
                    shape: textRect,
                    style: api.style({
                        fill: "transparent",
                        stroke: "transparent",
                        text: tip,
                        textFill: textColor
                    })
                }]
            }
            return item
        }

        function calcColorIndex(data, max_len) {
            let index = data
            if (typeof(data) === "string") {
                index = 0
                for (let i = 0; i < data.length; i++) {
                    index += data.codePointAt(i)
                }
            }
            return index % max_len
        }
        let colors = []
        for (let r = 0; r < 250; r += 50) {
            for (let g = 0; g < 250; g += 50) {
                for (let b = 0; b < 250; b += 50) {
                    colors.push(`rgb(${r},${g},${b})`)
                }
            }
        }

        // ["category", "begin_time", "end_time", "func_type", "height", "cmd", "func_name","uarch rate" "info"]

        function createSelector(labelText, options, onChanged) {
            let node = document.createElement("div")
            node.className = "filter-block"
            let label = document.createElement("label")
            label.innerText = labelText
            label.className = "filter-label"
            node.appendChild(label)
            let select = document.createElement("select")
            select.className = "filter-select"
            for (let o of options) {
                option = document.createElement("option")
                option.value = o
                option.innerText = "" + o
                select.appendChild(option)
            }
            select.onchange = (e) => {
                let node = e.target
                let filter_blocks = node.parentNode.parentNode.children
                let value_map = {}
                for (let i = 0; i < filter_blocks.length; i++) {
                    if (filter_blocks[i].className != "filter-block") continue
                    let labelNode = filter_blocks[i].children[0]
                    let valueNode = filter_blocks[i].children[1]
                    if (valueNode.value == "--") continue
                    value_map[labelNode.innerText] = valueNode.value
                }
                if (onChanged)
                    onChanged(value_map)
            }
            node.appendChild(select)
            return node
        }

        function uniqueColumnData(data, colIndex) {
            let col_data = []
            for (let i = 0; i < data.length; i++) {
                if (col_data.includes(data[i][colIndex])) continue;
                col_data.push(data[i][colIndex])
            }
            return col_data
        }
        //raw_data: 'category', 'begin_time', 'end_time', 'func_type', 'height', 'cmd', 'func_name', 'info'
        let previousZoomRange = null;
        let storedZoomRange = null;

        function showTimeChart(chart, header, raw_data, categories, color_col, title) {
            console.log("show time chart ing!")
            console.log("previousZoomRange:", previousZoomRange)
            let data = []
            let category_time = []
            let category_count = []
            for (let i = 0; i < categories.length; i++) {
                category_time.push(0)
                category_count.push(0)
            }
            let startTime = raw_data.length > 0 ? raw_data[0][1] : 0;
            for (let i = 0; i < raw_data.length; i++) {
                if (startTime > raw_data[i][1]) startTime = raw_data[i][1];
                category_time[raw_data[i][0]] += raw_data[i][2] - raw_data[i][1];
                category_count[raw_data[i][0]] += 1;
                data.push({
                    name: `${raw_data[i][3]}`,
                    value: raw_data[i],
                    itemStyle: {
                        normal: {
                            color: colors[calcColorIndex(raw_data[i][color_col], colors.length)],
                            // borderColor: "#FFFFFF",
                        }
                    }
                })
            }
            console.log("data:", data)
            let new_categories = [];
            let totalcycles = 0;
            for (let i = 0; i < category_time.length; i++) {
                totalcycles += category_time[i]
            }
            for (let i = 0; i < categories.length; i++) {
                new_categories.push(categories[i] +
                    "\ncount=" + category_count[i] +
                    "\ntotal=" + usec_str(category_time[i]) +
                    "\nProportion=" + (category_time[i] / totalcycles * 100).toFixed(2) + "%"
                )
            }
            console.log("new_categories:", new_categories)

            let option = {
                tooltip: {
                    alwaysShowContent: true,
                    position: function(pos, params, el, elRect, size) {
                        var obj = {
                            top: pos[1] - 30
                        };
                        if (pos[0] + size.contentSize[0] > size.viewSize[0]) {
                            obj['left'] = size.viewSize[0] - size.contentSize[0];
                        } else {
                            obj['left'] = pos[0];
                        }
                        return obj;
                    },
                    formatter: function(params) {
                        if (!params.value || !params.value.length || params.value.length != header.length) return ""
                        let tip = params.marker + params.name + ': ' + usec_str(params.value[2] - params.value[1])
                        tip += `<br>begin: ${usec_str(params.value[1])}`
                        tip += `<br>end: ${usec_str(params.value[2])}`
                        tip += `<br>cmd: ${usec_str(params.value[5])}`
                        tip += `<br>func_type: ${params.value[3]}`
                        tip += `<br>func_name: ${params.value[6]}`
                        tip += `<br>${params.value[params.value.length-1]}`
                        return tip;
                    },
                    axisPointer: {
                        show: true,
                        type: 'cross',
                        lineStyle: {
                            type: 'dashed',
                            width: 1
                        },
                        label: {
                            show: true,
                            formatter: function(param) {
                                if (param.axisDimension == 'x') {
                                    return usec_str(param.value)
                                }
                                return param.value
                            }
                        }
                    }
                },
                title: {
                    text: title ? title : "Cycle Chart",
                    left: 'center'
                },
                dataZoom: [{
                    type: 'slider',
                    filterMode: 'weakFilter',
                    showDataShadow: false,
                    height: 10,
                    borderColor: 'transparent',
                    backgroundColor: '#e2e2e2',
                    handleIcon: 'M10.7,11.9H9.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line
                    handleSize: 20,
                    handleStyle: {
                        shadowBlur: 6,
                        shadowOffsetX: 1,
                        shadowOffsetY: 2,
                        shadowColor: '#aaa'
                    },
                    bottom: 40,
                    realtime: true,
                    labelFormatter: ''
                }, {
                    type: 'inside',
                    realtime: true,
                    filterMode: 'weakFilter'
                }],
                grid: {
                    height: 500,
                },
                xAxis: {
                    min: startTime,
                    scale: true,
                    axisLabel: {
                        formatter: function(val) {
                            return (val);
                        }
                    },
                },
                yAxis: {
                    data: new_categories

                },
                toolbox: {
                    right: '10%',
                    feature: {
                        //dataZoom: {
                        //    yAxisIndex: 'none',
                        //    }
                        //},
                        restore: {},
                        saveAsImage: {},
                        myStoreTool: {
                            show: true,
                            title: "留存当前缩放区域",
                            icon: 'path://M797.6 383.3h-62.7v-74.1c0-56.7-22.4-109.9-63.1-150-40.6-39.9-94.5-61.9-151.8-61.9h-16c-57.3,0-111.2, 22-151.8,61.9-40.7, 40-63.1, 93.3-63.1, 150v74.1h-62.7c-71.3, 0-129.3, 58-129.3, 129.3v284.7c0, 71.3, 58, 129.3, 129.3, 129.3h571.3c71.3, 0, 129.3-58, 129.3-129.3V512.6c-0.1-71.3-58.1-129.3-129.4-129.3z, m-448.5-74.1c0-83.7, 69.5-151.8, 154.9-151.8h16c85.4,0 ,154.9, 68.1, 154.9, 151.8v74.1H349.1v-74.1z, m517.8, 488.1c0, 38.2-31.1, 69.3-69.3, 69.3H226.4c-38.2, 0-69.3-31.1-69.3-69.3V512.6c0-38.2, 31.1-69.3, 69.3-69.3h571.3c38.2, 0, 69.3, 31.1, 69.3, 69.3v284.7z, M512 485.8c-49.4 0-89.7 40.2-89.7 89.7 0 38.9 24.9 72.1 59.7 84.5v116.5c0 16.6 13.4 30 30 30s30-13.4 30-30V660c34.7-12.4 59.7-45.6 59.7-84.5 0-49.4-40.3-89.7-89.7-89.7z m0 60c16.4 0 29.7 13.3 29.7 29.7s-13.3 29.7-29.7 29.7-29.7-13.3-29.7-29.7 13.3-29.7 29.7-29.7z',
                            onclick: function() {
                                let option = chart.getOption();
                                let {
                                    startValue,
                                    endValue
                                } = option.dataZoom[1];
                                storedZoomRange = {
                                    startValue: startValue,
                                    endValue: endValue
                                };
                            }
                        },
                        myRevertTool: { //custom button
                            show: true,
                            title: "还原到上一缩放区域",
                            icon: 'path://M771.7,526.2c-59.6-59.6-138.8-92.4-223-92.4h-284L402.6, 296c11.7-11.7, 11.7-30.7, 0-42.4s-30.7-11.7-42.4 0L168.7, 445c-11.7, 11.7-11.7, 30.6-0.1, 42.3l191.5, 193.1c5.9, 5.9, 13.6, 8.9, 21.3, 8.9, 7.6, 0, 15.3-2.9, 21.1-8.7, 11.8-11.7, 11.8-30.7, 0.2-42.4L259.6, 493.9h289.2c68.2, 0, 132.3, 26.6, 180.6, 74.8, 48.2, 48.2, 74.8, 112.4, 74.8, 180.6, 0, 16.6, 13.4, 30, 30, 30s30-13.4, 30-30c-0.1-84.3-32.9-163.5-92.5-223.1z', // Icon path
                            onclick: function() {
                                //if (previousZoomRange) {
                                //    chart.dispatchAction({
                                //        type: 'dataZoom',
                                //        dataZoomIndex: 1,
                                //        startValue: previousZoomRange.startValue,
                                //        endValue: previousZoomRange.endValue,
                                //    });
                                //}
                                if (storedZoomRange) {
                                    chart.dispatchAction({
                                        type: 'dataZoom',
                                        dataZoomIndex: 1,
                                        startValue: storedZoomRange.startValue,
                                        endValue: storedZoomRange.endValue,
                                    });
                                }
                            }
                        }
                    }
                },
                series: [{
                    type: 'custom',
                    renderItem: renderItem,
                    itemStyle: {
                        opacity: 0.8
                    },
                    encode: {
                        x: [1, 2],
                        y: 0
                    },
                    data: data,
                }]
            };

            if (option && typeof option === "object") {
                chart.setOption(option, true);
            }

            return chart
        }

        let clickedRowIndex = null;

        function updateDataTable(begin, end, original_data) {
            console.log("calling updateDataTable")
            let matchedIndex = null;
            let matchedCategory = null;

            //console.log("filtered_data:", filtered_data)
            for (let i = 0; i < original_data.length; i++) {
                let rowBegin = original_data[i][1];
                let rowEnd = original_data[i][2];
                if (rowBegin === begin && rowEnd === end) {
                    matchedIndex = i;
                    matchedCategory = original_data[i][0];
                    rangeStart = 0; // Math.max(0, i - 10);
                    rangeEnd = original_data.length; // Math.min(filtered_data.length, i + 11);
                    break;
                }
            }

            if (matchedIndex !== null) {
                let highlightedRow = matchedIndex - rangeStart;
                clickedRowIndex = matchedIndex;

                // If a matching row is found in the data, update the table to display it
                showFilterDataTable("data-list", time_header, original_data, "Cycle Information ", categories, matchedCategory, matchedIndex);
                let categorySelector = document.getElementById("table_filter");
                if (categorySelector) {
                    categorySelector.value = matchedCategory;
                }
            } else {
                console.log("Matching row not found for begin:", begin, "end:", end);
            }
        }

        let chartHandle = null

        function showDataInChart(elem_id, header, data, categories, filter_cols, color_col) {
            let original_data = [...data];
            //console.log("original_data", original_data)
            filtered_data = data
            var dom = document.getElementById(elem_id);
            if (dom.childNodes.length == 0) {
                chartNode = document.createElement("div")
                chartNode.style = "height:650px;width:95%";
                dom.appendChild(chartNode)
                filterBlock = document.createElement("div")
                filterBlock.style = "text-align: center";
                dom.appendChild(filterBlock)
                chartHandle = echarts.init(chartNode);
                chartHandle.on("datazoom", (params) => {
                    let option = chartHandle.getOption();
                    let {
                        startValue,
                        endValue
                    } = option.dataZoom[1];

                    // Store the current zoom range before updating
                    previousZoomRange = {
                        startValue: startValue,
                        endValue: endValue
                    };
                });
                for (let col of filter_cols) {
                    let col_data = uniqueColumnData(data, col)
                    col_data.sort()
                    col_data.unshift("--")
                    filterBlock.appendChild(createSelector(header[col], col_data, (value_map) => {
                        if (data.length == 0) return
                        let colIndex_value = {}
                        for (let key in value_map) {
                            let index = header.indexOf(key)
                            let value = value_map[key]
                            if (typeof(data[0][index]) === "number") {
                                value = Number(value)
                            }
                            colIndex_value[index] = value_map[key]
                        }
                        if (Object.keys(value_map).length > 0) {
                            filtered_data = []
                            for (let i = 0; i < data.length; i++) {
                                let need = true
                                for (let colIndex in colIndex_value) {
                                    if (data[i][colIndex] != colIndex_value[colIndex]) {
                                        need = false
                                        break
                                    }
                                }
                                if (!need) continue;
                                filtered_data.push(data[i])
                            }
                        } else {
                            filtered_data = data
                        }
                        showTimeChart(chartHandle, header, filtered_data, categories, color_col)
                    }));
                }
                showTimeChart(chartHandle, header, data, categories, color_col)
            }
            if (chartHandle) {
                chartHandle.set_time_range = function(begin_usec, end_usec) {
                        chartHandle.dispatchAction({
                            type: 'dataZoom',
                            dataZoomIndex: 1,
                            start: null,
                            end: null,
                            startValue: begin_usec,
                            endValue: end_usec,
                        })
                    }
                    // the following code will slow the chart
                    // chartHandle.on("datazoom", (params) => {
                    //     let option = chartHandle.getOption()
                    //     let {startValue, endValue} = option.dataZoom[1]
                    //     set_chart_time_range(startValue, endValue, chartHandle)
                    // })

                chartHandle.on("click", (params) => {
                    let val = params.value
                    if (params.seriesIndex == 0) {
                        let range = val[2] - val[1]
                        let begin_usec = val[1]
                        let end_usec = val[2]
                        set_chart_time_range(begin_usec - range * 1.2, end_usec + range * 2)
                    }
                    let updatedData = data.map((item, index) => {
                        // Copy the itemStyle object if it exists, otherwise create a new one
                        let itemStyle = item.itemStyle ? {...item.itemStyle
                        } : {
                            normal: {
                                color: colors[calcColorIndex(item[color_col], colors.length)]
                            }
                        };
                        // If this is the clicked item, set the color to red
                        if (index === params.dataIndex) {
                            console.log("item:", item)
                            console.log("index:", index)
                            console.log("params.index", params.dataIndex)
                            itemStyle.normal.color = 'red';
                        }
                        return {
                            name: `${item[3]}`,
                            value: item,
                            itemStyle: itemStyle
                        };
                    });

                    // Update the chart with the new data
                    chartHandle.setOption({
                        series: [{
                            data: updatedData
                        }]
                    });

                    let selectedData = params.value;
                    let begin = selectedData[1];
                    let end = selectedData[2];
                    console.log("Chart clicked with begin:", begin, "end:", end);

                    updateDataTable(begin, end, original_data);
                })
            }

            return chartHandle
        }
    </script>
    <script type="text/javascript">
        let YLABEL_LEFT = 10
        let YLABEL_WIDTH = 250

        function clipRectByRect(params, rect) {
            let srcRect = {
                x: rect[0],
                y: rect[1],
                width: rect[2],
                height: rect[3],
            }
            return echarts.graphic.clipRectByRect(srcRect, params.coordSys);
        }

        function getMemColor(mem_addr) {
            let r = ((mem_addr & 0xFF) * 211) % 255
            let g = ((mem_addr & 0xFF00) * 211) % 255
            let b = ((mem_addr & 0xFF0000) * 211) % 255
            return `rgb(${r}, ${g}, ${b})`
        }

        function addrToText(addr) {
            addr = Math.round(addr)
            return `0x${addr.toString(16).toUpperCase()}`
        }

        function processAddr(op_record, suffixnum) {
            const result = [];
            const hexToDec = (hex) => parseInt(hex, 16);
            const base = hexToDec('0x25000000');

            for (let op of op_record) {
                const sublist = [...op];
                const hexAddr = op[3];
                const decAddr = hexToDec(hexAddr);
                //const realAddr = decAddr - base - suffixnum * hexToDec('1000000');
                const realAddr = decAddr - suffixnum * hexToDec('1000000');
                sublist[3] = realAddr;
                result.push(sublist);
            }
            return result
        }

        function sizeToText(size) {
            if (size < 1024) {
                return `${size}B`;
            } else if (size < 1024 * 1024) {
                return `${(size / 1024).toFixed(2)}KB`
            } else if (size < 1024 * 1024 * 1024) {
                return `${(size / 1024 / 1024).toFixed(2)}MB`
            } else {
                return `${(size / 1024 / 1024 / 1024).toFixed(2)}GB`
            }
            return `${size}B`;
        }

        function memPartitionRender(params, api) {
            let axisLabel = {
                type: 'group',
                // position: [YLABEL_LEFT, y],
                children: []
            };
            var x = YLABEL_LEFT
            var w = YLABEL_WIDTH * 2
            var y = api.coord([0, api.value(0)])[1]
            var h = api.coord([0, api.value(1)])[1] - y
            clipRect = clipRectByRect(params, [x, y, w, h])
            clipRect && (clipRect.x = YLABEL_LEFT);
            if (clipRect) {
                axisLabel.children.push({
                    type: 'rect',
                    shape: clipRect,
                    style: api.style()
                })
                clipRect.height = Math.max(20, clipRect.height)
                if (clipRect.height > 18) {
                    let size = api.value(3)
                    axisLabel.children.push({
                        type: 'text',
                        style: {
                            x: clipRect.x,
                            y: clipRect.y + 20,
                            text: ` ${api.value(4)}: ${sizeToText(size)}`,
                            textVerticalAlign: 'bottom',
                            textAlign: 'left',
                            textFill: '#fff',
                            fontSize: 15,
                        }
                    })
                }
                if (clipRect.height > 36) {
                    let start_addr = api.value(2)
                    let size = api.value(3)
                    let end_addr = start_addr + size
                    let addr_text = ` ${addrToText(start_addr)}~${addrToText(end_addr)}`
                    axisLabel.children.push({
                        type: 'text',
                        style: {
                            x: clipRect.x,
                            y: clipRect.y + 36,
                            text: addr_text,
                            textVerticalAlign: 'bottom',
                            textAlign: 'left',
                            textFill: '#fff',
                            fontSize: 11,
                        }
                    })
                }
            }
            return axisLabel
        }

        function memRecordRender(params, api) {
            var left_top = api.coord([api.value(0), api.value(2)])
            var right_botom = api.coord([api.value(1), api.value(3)])
            let axisLabel = {
                type: 'group',
                // position: left_top,
                children: []
            };
            let x = left_top[0]
            let y = left_top[1]
            let w = Math.max(5, right_botom[0] - left_top[0])
            let h = Math.max(5, right_botom[1] - left_top[1])
            let clipRect = clipRectByRect(params, [x, y, w, h])
            axisLabel.children.push({
                type: 'rect',
                shape: clipRect,
                style: api.style()
            })

            let text_y = clipRect ? clipRect.y + 5 : 5;

            function push_text(container, text, text_y, clipRect) {
                let textRect = echarts.format.getTextRect(text);
                let text_x = clipRect ? clipRect.x : 0;
                if (clipRect && clipRect.height + clipRect.y >= text_y + textRect.height && clipRect.width >= textRect.width) {
                    text_y = text_y + textRect.height;
                } else {
                    text = ""
                }
                container.push({
                    type: 'text',
                    style: {
                        x: text_x,
                        y: text_y,
                        text: text,
                        textVerticalAlign: 'bottom',
                        textAlign: 'left',
                        textFill: '#fff',
                    }
                })
                return text_y
            }

            let text = ""
            text = " " + api.value(7).split(",")[0] + ": " + (api.value(4) ? "WRITE" : "READ")
            text_y = push_text(axisLabel.children, text, text_y, clipRect)

            let start_addr = api.value(5)
            let size = api.value(6)
            let end_addr = start_addr + size
            text = ` ${addrToText(start_addr)}~${addrToText(end_addr)} (${sizeToText(size)})`
            text_y = push_text(axisLabel.children, text, text_y, clipRect)

            let full_desc = api.value(7)
            text = full_desc.slice(full_desc.indexOf(",") + 1)
            text_y = push_text(axisLabel.children, text, text_y, clipRect)

            return axisLabel
        }

        function statDataDensity(data, range_begin_idx, range_end_idx, value_begin_idx, value_end_idx) {
            let all_edges = []
            let all_values = []
            for (let d of data) {
                if (all_edges.indexOf(d[range_begin_idx]) == -1) {
                    all_edges.push(d[range_begin_idx])
                    all_values.push(0)
                }
                if (all_edges.indexOf(d[range_end_idx]) == -1) {
                    all_edges.push(d[range_end_idx])
                    all_values.push(0)
                }
            }
            all_edges = all_edges.sort((a, b) => a - b)
            for (let d of data) {
                let begin = d[range_begin_idx]
                let end = d[range_end_idx]
                let value = d[value_end_idx] - d[value_begin_idx]
                for (let i = 0; i < all_edges.length; i++) {
                    let edge = all_edges[i]
                    if (edge >= begin && edge < end) {
                        all_values[i] += value;
                    }
                }
            }
            edge_value = []
            for (let i = 0; i < all_edges.length; i++) {
                edge_value.push([all_edges[i], all_values[i]])
            }
            return edge_value
        }

        function recordInPartition(record, partition) {
            if (!partition) return false;
            for (let p of partition) {
                if (record[4] == 0) return true;
                if (record[3] >= p[0] && record[3] <= p[0] + p[1]) {
                    return true;
                }
            }
            return false
        }

        function showMemChart(id, partition, op_record, title, begin_usec, end_usec) {
            let dom = document.getElementById(id);
            if (!partition) {
                partition = []
            }
            if (op_record && op_record.length > 0) {
                for (let op of op_record) {
                    if (!recordInPartition(op, partition)) {
                        partition.push([op[3], op[4], op[op.length - 1]]) //addr, size, desc
                    }
                }
            }
            if (!partition || !op_record || partition.length == 0 || op_record.length == 0) {
                dom.style = "display: none";
                return null;
            }
            dom.style = "display: block";
            let myChart = echarts.init(dom);
            let mem_end = 0
            let mem_start = 0
            if (partition.length > 0) {
                mem_end = partition[0][0] + partition[0][1];
                mem_start = partition[0][0]
                for (let p of partition) {
                    if (p[0] < mem_start) mem_start = p[0];
                    if (p[1] + p[0] > mem_end) mem_end = p[1] + p[0];
                }
            } else {
                mem_end = op_record[0][3] + op_record[0][4]
                mem_start = op_record[0][3]
                for (let p of op_record) {
                    if (p[3] < mem_start) mem_start = p[3];
                    if (p[3] + p[4] > mem_end) mem_end = p[3] + p[4];
                }
            }
            let partition_data = []
            for (let p of partition) {
                partition_data.push({
                    name: p[2],
                    value: [mem_end - p[0], mem_end - (p[0] + p[1]), p[0], p[1], p[2]],
                    itemStyle: {
                        normal: {
                            color: getMemColor(p[0]),
                            borderColor: "#FFFFFF",
                        }
                    }
                })
            }

            let record_data = []
                //begin end addr size type(0:R, 1:W) desc
            let write_data = []
            let read_data = []
            let all_data = []
            for (let op of op_record) {
                let item_data = [op[0], op[1], mem_end - op[3], mem_end - (op[3] + op[4]), op[2], op[3], op[4], op[5]]
                record_data.push({
                    name: op[op.length - 1],
                    value: item_data,
                    itemStyle: {
                        normal: {
                            opacity: 0.6,
                            color: op[2] ? "red" : "green",
                            borderColor: "#FFFFFF",
                            borderWidth: 1,
                        }
                    }
                })
                all_data.push(item_data);
                if (item_data[4] == 0) {
                    read_data.push(item_data)
                } else {
                    write_data.push(item_data)
                }
            }
            let mem_used_stat = statDataDensity(all_data, 3, 2, 0, 1)
            let used_stat = []
            if (mem_used_stat.length > 0) {
                used_stat.push([0, mem_used_stat[0][0]])
                for (let i = 0; i < mem_used_stat.length - 1; i++) {
                    used_stat.push([-mem_used_stat[i][1], mem_used_stat[i][0]])
                    used_stat.push([-mem_used_stat[i][1], mem_used_stat[i + 1][0]])
                }
                if (mem_used_stat.length > 0) {
                    used_stat.push([0, mem_used_stat[mem_used_stat.length - 1][0]])
                }
            }
            let write_stat = statDataDensity(write_data, 0, 1, 3, 2)
            let read_stat = statDataDensity(read_data, 0, 1, 3, 2)
            let all_stat = statDataDensity(all_data, 0, 1, 3, 2)
            let option = {
                tooltip: {
                    alwaysShowContent: true,
                    formatter: (params) => {
                        let tip = params.marker + params.name
                        let val = params.value
                        if (val.length == 5) {
                            let start_addr = val[2]
                            let size = val[3]
                            let end_addr = start_addr + size
                            let addr_text = `${addrToText(start_addr)}~${addrToText(end_addr)}`
                            let size_text = sizeToText(size)
                            tip += ": " + size_text + "<br>" + addr_text
                        } else if (val.length == 8) {
                            let all_params = params.name.split(", ")
                            tip = params.marker + all_params[0]
                            let start_addr = val[5]
                            let size = val[6]
                            let end_addr = start_addr + size
                            let addr_text = `${addrToText(start_addr)}~${addrToText(end_addr)}`
                            let size_text = sizeToText(size)
                            tip += "<br>size=" + size_text + "<br>" + addr_text
                            for (i = 1; i < all_params.length; i++) {
                                tip += "<br>" + all_params[i];
                            }
                        } else {
                            let start_addr = val[0]
                            let size = val[1]
                            let end_addr = start_addr + size
                            let addr_text = `${addrToText(start_addr)}~${addrToText(end_addr)}`
                            let size_text = sizeToText(size)
                            tip += "<br>size=" + size_text + "<br>" + addr_text
                        }
                        return tip;
                    },
                    axisPointer: {
                        show: true,
                        type: 'cross',
                        lineStyle: {
                            type: 'dashed',
                            width: 1
                        },
                        label: {
                            show: true,
                            formatter: function(param) {
                                if (param.axisDimension == 'x') {
                                    return (param.value).toFixed(2)
                                }
                                return addrToText(Math.round(mem_end - param.value))
                            }
                        }
                    }
                },
                toolbox: {
                    left: 'right',
                    feature: {
                        dataZoom: {
                            yAxisIndex: 0,
                        },
                        restore: {},
                        saveAsImage: {}
                    }
                },
                title: {
                    text: title,
                    left: "center",
                },
                dataZoom: [{
                    type: "slider",
                    xAxisIndex: [0, 1],
                    filterMode: 'weakFilter',
                    handleIcon: 'M10.7,11.9H9.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                    handleSize: '80%',
                    height: "3%",
                    top: "15%",
                }, {
                    type: "inside",
                    id: "insideX",
                    filterMode: "weakFilter",
                    zoomOnMouseWheel: true,
                    moveOnMouseMove: true,
                }, {
                    type: "slider",
                    yAxisIndex: [0, 2],
                    zoomLock: false,
                    filterMode: 'weakFilter',
                    handleIcon: 'M10.7,11.9H9.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',
                    handleSize: '80%',
                    labelFormatter: (val) => {
                        return addrToText(Math.round(mem_end - val));
                    },
                }, {
                    filterMode: 'weakFilter',
                    type: "inside",
                    id: "insideY",
                    yAxisIndex: [0, 2],
                    zoomOnMouseWheel: false,
                    moveOnMouseMove: true,
                    moveOnMouseWheel: false,
                }],

                grid: [{
                    show: true,
                    height: "80%",
                    top: "18%",
                    left: YLABEL_LEFT + YLABEL_WIDTH,
                    right: 40,
                    backgroundColor: "#FFF",
                    borderWidth: 0,
                }, {
                    show: true,
                    height: "10%",
                    top: "5%",
                    left: YLABEL_LEFT + YLABEL_WIDTH,
                    right: 40,
                }, {
                    show: true,
                    height: "80%",
                    top: "18%",
                    left: YLABEL_LEFT,
                    width: YLABEL_WIDTH,
                }],
                xAxis: [{
                    scale: true,
                    axisLabel: {
                        formatter: function(val) {
                            return val + ' cycle';
                        }
                    },
                    position: "top",
                    gridIndex: 0,
                }, {
                    show: false,
                    scale: true,
                    gridIndex: 1,
                }, {
                    show: false,
                    gridIndex: 2,
                    position: "bottom",
                    scale: true,
                }],
                yAxis: [{
                    axisTick: {
                        show: false
                    },
                    splitLine: {
                        show: false
                    },
                    axisLine: {
                        show: true
                    },
                    axisLabel: {
                        formatter: (val) => {
                            return addrToText(mem_end - val)
                        },
                        show: true
                    },
                    min: 0,
                    max: mem_end - mem_start,
                    width: YLABEL_WIDTH,
                    gridIndex: 0,
                }, {
                    name: "大小",
                    type: "value",
                    axisLabel: {
                        formatter: function(val) {
                            return sizeToText(val)
                        }
                    },
                    gridIndex: 1,
                }, {
                    show: false,
                    min: 0,
                    max: mem_end - mem_start,
                    width: YLABEL_WIDTH,
                    gridIndex: 2,
                }],
                series: [{
                    type: "custom",
                    renderItem: memPartitionRender,
                    encode: {
                        x: -1,
                        y: [0, 1],
                    },
                    data: partition_data,
                    itemStyle: {
                        opacity: 0.6
                    },
                    gridIndex: 0,
                }, {
                    type: "custom",
                    renderItem: memRecordRender,
                    encode: {
                        x: [0, 1],
                        y: [2, 3],
                    },
                    data: record_data,
                    itemStyle: {
                        opacity: 0.8
                    },
                    gridIndex: 0,
                }, {
                    id: "write_stat",
                    type: "line",
                    smooth: true,
                    symbolSize: 5,
                    data: write_stat,
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    itemStyle: {
                        color: "red",
                    }
                }, {
                    id: "read_stat",
                    type: "line",
                    smooth: true,
                    symbolSize: 5,
                    data: read_stat,
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    itemStyle: {
                        color: "green",
                    }
                }, {
                    id: "all_stat",
                    type: "line",
                    smooth: true,
                    symbolSize: 5,
                    data: all_stat,
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    itemStyle: {
                        color: "#222222",
                    }
                }, {
                    id: "mem_used_time",
                    type: "line",
                    data: used_stat,
                    xAxisIndex: 2,
                    symbolSize: 0,
                    yAxisIndex: 2,
                    itemStyle: {
                        color: "orange",
                        opacity: 0.5,
                    },
                    lineStyle: {
                        width: 2,
                    },
                    zlevel: -1,
                    z: -1,
                }],
            }
            if (typeof(begin_usec) != "undefined") {
                option.dataZoom[0].startValue = begin_usec
                option.dataZoom[1].startValue = begin_usec
            }
            if (typeof(end_usec) != "undefined") {
                option.dataZoom[0].endValue = end_usec
                option.dataZoom[1].endValue = end_usec
            }
            myChart.setOption(option)
            myChart.set_time_range = function(begin_usec, end_usec) {
                    myChart.dispatchAction({
                        type: 'dataZoom',
                        dataZoomIndex: 1,
                        start: null,
                        end: null,
                        startValue: begin_usec,
                        endValue: end_usec,
                    })
                }
                // myChart.on("datazoom", (params) => {
                //     let option = myChart.getOption()
                //     let { startValue, endValue } = option.dataZoom[1]
                //     set_chart_time_range(startValue, endValue, myChart)
                // })
            myChart.on("click", (params) => {
                let val = params.value
                if (params.seriesIndex == 0) {
                    let range = val[0] - val[1];
                    let scale_range = 1.2 * range;
                    let pad = (scale_range - range) / 2;
                    myChart.dispatchAction({
                        type: 'dataZoom',
                        dataZoomIndex: 3,
                        start: null,
                        end: null,
                        startValue: val[1] - pad,
                        endValue: val[0] + pad,
                    })
                } else if (params.seriesIndex == 1) {
                    let vrange = val[2] - val[3];
                    myChart.dispatchAction({
                        type: 'dataZoom',
                        dataZoomIndex: 3,
                        start: null,
                        end: null,
                        startValue: val[2] - 8 * vrange,
                        endValue: val[3] + 2 * vrange,
                    })
                    let hrange = val[1] - val[0];
                    let begin_usec = val[0] - hrange
                    let end_usec = val[1] + hrange
                    set_chart_time_range(begin_usec, end_usec)
                }
            })
            return myChart
        }

        function createShowFunc(container_id, partition, op_record, title) {
            return function(e) {
                if (e.target.checked) {
                    let zoomOption = all_charts[0].getOption().dataZoom[1]
                    let chart = showMemChart(container_id, partition, op_record, title, zoomOption.startValue, zoomOption.endValue)
                    if (chart) {
                        all_charts.push(chart)
                    }
                } else {
                    new_charts = []
                    for (let c of all_charts) {
                        if (c && c._dom.id == container_id) {
                            c.clear()
                            c._dom.style = "display:none"
                        } else {
                            new_charts.push(c)
                        }
                    }
                    all_charts = new_charts
                }
            }
        }

        function showFilterDataTable(id, header, data, caption, categories, current_category, highlightedRow = null) {
            console.log("The function filterDataTable is called!")
            console.log("options in showFilterData:", chartHandle.getOption());
            let max_show = data.length
            let category_idx = 0
            let node = document.getElementById(id)
            if (!node) return;
            if (typeof(current_category) == "undefined") {
                current_category = 0
                let filter = document.querySelector("#table_filter")
                if (filter) current_category = filter.selectedIndex
            }
            node.innerHTML = ""
            node.style = "display:block"
            let table = document.createElement("table")
            table.id = `table-${id}`
            table.className = "data-table"

            let capNode = table.createCaption()
            capNode.innerText = caption
            if (categories.length > 0) {
                let select_node = document.createElement("div")
                select_node.className = "filter-block"
                let label = document.createElement("label")
                label.innerText = `(top${max_show}) :`
                label.className = "filter-label"
                select_node.appendChild(label)
                let select = document.createElement("select")
                select.className = "filter-select"
                select.id = "table_filter"
                for (let i = 0; i < categories.length; i++) {
                    option = document.createElement("option")
                    option.value = i
                    option.innerText = "" + categories[i]
                    select.appendChild(option)
                }
                select.selectedIndex = current_category
                select_node.append(select)
                select.onchange = (e) => {
                    let value = e.target.value
                    showFilterDataTable(id, header, data, caption, categories, value)
                }
                capNode.appendChild(select_node)
            }
            if (!header.includes("Cmd Break(cycles)")) {
                header.push("Cmd Break(cycles)");
            }

            let usec_cols = [1, 2, header.length - 2]
            let new_data = [] //single category's data
            console.log("new_data:", new_data)
            for (let d of data) {
                if (d[category_idx] == current_category) {
                    let item = []
                    for (let i = 0; i < header.length - 2; i++) {
                        item.push(d[i])
                    }
                    item.push(d[usec_cols[1]] - d[usec_cols[0]]);
                    new_data.push(item)
                }
            }
            let filtered_highlightedRow = null;
            console.log("highlightedRow:", highlightedRow)
            console.log("data[highlightedRow]:", data[highlightedRow])
            if (highlightedRow !== null) {
                for (let i = 0; i < new_data.length; i++) {
                    if (data[highlightedRow][0] === new_data[i][0] &&
                        data[highlightedRow][1] === new_data[i][1] &&
                        data[highlightedRow][2] === new_data[i][2]) {
                        filtered_highlightedRow = i;
                        break;
                    }
                }
            }
            console.log("filtered_highlightedRow:", filtered_highlightedRow)
            let body = table.createTBody()
            let show_len = max_show > new_data.length ? new_data.length : max_show;

            let highlightedRowElement = null;
            let previouslyHighlight = null;
            for (let r = 0; r < show_len; r++) {
                let row_data = new_data[r];
                let row_body = document.createElement("tr");

                if (r === filtered_highlightedRow) {
                    row_body.style.background = "red";
                    highlightedRowElement = row_body; // Store the highlighted row element to pinpoint the location
                    previouslyHighlight = row_body;
                }
                row_body.onclick = (e) => {
                    if (previouslyHighlight) {
                        previouslyHighlight.style.background = ""; // Reset to original background
                    }
                    row_body.style.background = "red";
                    previouslyHighlight = row_body;
                    let range = row_data[2] - row_data[1];
                    updateChartColor(data, row_data[1], row_data[2]);
                    set_chart_time_range(row_data[1] - range * 0.5, row_data[2] + range * 0.5);
                }
                body.appendChild(row_body);

                // Calculate diff_cycle
                let diff_cycle = 0;
                if (r > 0 && new_data[r - 1][0] === row_data[0]) {
                    diff_cycle = row_data[1] - new_data[r - 1][2];
                }
                row_data.push(diff_cycle);
                // Update new_data with the new row data
                new_data[r] = row_data;
                for (let c = 0; c < row_data.length; c++) {
                    let col_body = document.createElement("td");
                    if (c === row_data.length - 1 || usec_cols.indexOf(c) >= 0) {
                        col_body.innerHTML = usec_str(row_data[c]);
                    } else {
                        col_body.innerHTML = row_data[c];
                    }
                    row_body.appendChild(col_body);
                }
            }
            //after the making rows loop, scroll the container to the highlighted row
            if (highlightedRowElement) {
                console.log("The scroll should be at the view spot")
                console.log("highlightedRowElement:", highlightedRowElement)
                setTimeout(() => {
                    highlightedRowElement.scrollIntoView({
                        behavior: "smooth",
                        block: "center"
                    });
                }, 0);
            }
            let head = table.createTHead()
            let row = document.createElement("tr")
            head.appendChild(row)
            for (let i = 0; i < header.length; i++) {
                let col = document.createElement("td")
                col.innerText = header[i]
                col.className = `header-${i}`
                if (data.length > 0) {
                    col.setAttribute("type", typeof(data[0][i]))
                }
                col.onclick = (e) => {
                    let states = e.target.className.split("-")
                    let col_idx = parseInt(states[1])
                    let is_asc = states[0] === "asc"
                    sortTableByColumn(e, new_data, usec_cols)
                }
                row.appendChild(col)
            }
            node.appendChild(table)
        }

        function updateChartColor(data, begin, end) {
            if (!chartHandle) return;

            // Find the index of the data item that matches the begin and end times
            let matchedIndex = data.findIndex(item => item[1] === begin && item[2] === end);
            console.log("matchedIndex for table to chart:", matchedIndex)
                // Create a copy of the data array with the color updated for the matched item
            let updatedData = data.map((item, index) => {
                let itemStyle = {
                    normal: {
                        color: colors[calcColorIndex(item[color_col], colors.length)]
                    }
                };
                if (index === matchedIndex) {
                    itemStyle.normal.color = 'red';
                }
                return {
                    name: `${item[3]}`,
                    value: item,
                    itemStyle: itemStyle
                };
            });

            // Update the chart with the new data
            chartHandle.setOption({
                series: [{
                    data: updatedData
                }]
            });
        }

        //生成uArch rate点图
        function createRateLine(containerId, data, title) {

            let xData = data.map(item => item[5]); // 提取cmd_id作为横轴
            let yData = data.map(item => item[4]); // 提取uarch_rate(height)

            //console.log("xData:", xData)
            //console.log("yData:", yData)

            let totalPoints = data.length;
            let lessThanOnePoints = data.filter(item => item[4] < 1).length;

            let chart = echarts.init(document.getElementById(containerId));
            let option = {
                title: {
                    text: `${title}\nTotal counts: ${totalPoints}, rate<100%: ${lessThanOnePoints}`,
                    left: 'center',
                    top: 'top',
                    textStyle: {
                        fontSize: 16
                    }
                },
                xAxis: {
                    type: 'value',
                },
                yAxis: {
                    type: 'value',
                    axisLabel: {
                        formatter: (value) => `${(value).toFixed(2)}%`
                    }
                },
                tooltip: {
                    trigger: 'item',
                    formatter: function(params) {
                        let [cmdId, rate] = params.value;
                        let matchingData = data.find(d => d[5] === cmdId);
                        let duration = matchingData[2] - matchingData[1];
                        return `Cmd ID: ${cmdId}<br/>Rate: ${rate.toFixed(2)}%<br/>Duration: ${duration}cycles`
                    }
                },
                series: [{
                    data: data.map(item => [item[5], item[4] * 100]),
                    type: 'scatter',
                    symbolSize: (value) => {
                        let duration = data.find(d => d[5] === value[0])[2] - data.find(d => d[5] === value[0])[1];
                        let baseSize = 5; // Adjust this as needed
                        let scaleFactor = 0.05; // Adjust this as needed
                        let adjustedSize = baseSize + (100 - value[1]) * duration / 100 * scaleFactor;
                        return (value[1] < 100 && duration > 0) ? adjustedSize : baseSize;
                    },
                    itemStyle: {
                        color: (param) => param.value[1] < 100 ? 'red' : 'blue'
                    }
                }],
                dataZoom: [{
                    type: 'slider',
                    xAxisIndex: 0,
                    filterMode: 'weakFilter'
                }, {
                    type: 'inside', // 内置型数据区域缩放组件，可以直接滑动鼠标
                    xAxisIndex: 0,
                    filterMode: 'weakFilter'
                }]
            };
            chart.setOption(option);
            return chart;
        }

        let charts = []

        // 生成饼图
        function processAndGeneratePieChart(elementId, rawData, header, pieTitle) {
            let nameData = [];
            let typeData = [];
            let functionNames = {};
            let functionTypes = {};
            let totalDuration = 0;
            funcTypeIndex = header.indexOf("func_type");
            funcNameIndex = header.indexOf("func_name")
            for (let i = 0; i < rawData.length; i++) { //["category", "begin_time", "end_time", "func_type", "height", "cmd", "func_name", "info"]
                let startCycle = rawData[i][1];
                let endCycle = rawData[i][2];
                let duration = endCycle - startCycle;
                let functionType = rawData[i][funcTypeIndex];
                let functionName = rawData[i][funcTypeIndex];

                totalDuration += duration;

                if (!functionNames.hasOwnProperty(functionName)) {
                    functionNames[functionName] = {
                        type: functionType,
                        duration: duration
                    };
                } else {
                    functionNames[functionName].duration += duration;
                }

                if (!functionTypes.hasOwnProperty(functionType)) {
                    functionTypes[functionType] = duration;
                } else {
                    functionTypes[functionType] += duration;
                }
            }

            for (let name in functionNames) {
                nameData.push({
                    name: name,
                    value: functionNames[name].duration * 100 / totalDuration
                });
            }

            for (let type in functionTypes) {
                typeData.push({
                    name: type,
                    value: functionTypes[type] * 100 / totalDuration
                });
            }

            let pieOption = {
                title: {
                    text: pieTitle,
                    subtext: 'Outer Ring: Func_type; Inner Ring: Func_name',
                    left: 'center',
                    top: 'top',
                    textStyle: {
                        fontSize: 18
                    },
                    subtextStyle: {
                        align: 'center',
                        fontSize: 14
                    }
                },
                tooltip: {
                    trigger: 'item',
                    formatter: function(params) {
                        let percentage = params.percent.toFixed(2);
                        let name = params.name;
                        let value = params.value;
                        let total = (value * totalDuration / 100).toFixed(2);
                        return `${name}: ${percentage}% (${total} cycles)`;
                    }
                },
                series: [{
                    name: 'Function Types',
                    type: 'pie',
                    radius: ['60%', '90%'],
                    data: typeData,
                    fontSize: 12
                }, {
                    name: 'Function Names',
                    type: 'pie',
                    radius: ['0%', '50%'],
                    data: nameData,
                    fontSize: 12
                }]
            };

            let pieChart = echarts.init(document.getElementById(elementId));
            pieChart.setOption(pieOption);
            charts.push(pieChart)
        }
    </script>

    <script type="text/javascript">
        if (typeof(page_caption) !== "undefined") {
            document.querySelector("#page-caption").innerText = page_caption
        }

        const tabs = document.getElementsByClassName('tabs');
        console.log("tabs:", tabs)

        function attachListeners(checkBoxes, id) {
            checkBoxes.forEach((checkBoxId) => {
                const checkBox = document.getElementById(checkBoxId);
                if (checkBox && checkBox.checked) {
                    checkBox.click();
                    checkBox.click();
                }
            });
        }

        // Store time data in an object instead of separate variables
        let dataCount = Object.keys(window).filter(key => key.startsWith('time_data')).length;
        console.log("dataCount", dataCount)
        if (dataCount > 1) {
            let tab = document.createElement('div');
            tab.className = 'tab';
            tab.innerText = 'Overall View';
            tabs[0].appendChild(tab);
        }

        for (let i = 1; i <= dataCount; i++) {
            let tab = document.createElement('div');
            tab.className = 'tab';
            tab.innerText = 'Core ' + i;
            tabs[0].appendChild(tab);
        }

        tabs[0].addEventListener("click", function(e) {
            if (!e.target.classList.contains('tab')) return;
            let tabName = e.target.outerText; //get the name of the tab
            console.log("tabName:", tabName)
            const checkBoxContainers = [
                document.querySelector(".config-item"),
                document.querySelector(".config-localmem"),
                document.querySelector(".config-item:nth-child(3)")
            ];
            let checkBoxes = ["show_data_table", "show_localmem", "tiu_uarch_rate"];
            if (tabName === "Overall View") {
                // Hide the checkbox containers
                checkBoxContainers.forEach((container) => {
                    container.style.display = 'none';
                });

                // Dispose all the charts
                charts.forEach(chart => chart.dispose());
                checkBoxes.forEach((checkBoxId) => {
                    const checkBox = document.getElementById(checkBoxId);
                    if (checkBox) {
                        checkBox.checked = false;
                        checkBox.dispatchEvent(new Event('change'));
                    }
                });
                charts = []; // Clear the charts array
                document.querySelectorAll('[id^="time-container"]').forEach(el => el.style.display = 'none');
                document.getElementById('summary-table').style.display = 'block';
                document.getElementById('summary-table').innerHTML = '';
                if (typeof(summary_header) !== "undefined") {
                    showDataTable("summary-table", summary_header, summary_data, summary_caption)
                }
                createMsgChart(cycleData, categories);
                document.getElementById('msg-container').style.display = 'block'; // Show the message chart container

            } else {
                console.log("我在core page")
                checkBoxContainers.forEach((container) => {
                    container.style.display = 'inline-block';
                });

                document.getElementById('summary-table').style.display = 'none';
                document.getElementById('msg-container').style.display = 'none';
                let id = e.target.outerText.split(' ')[1]; // Get the ID number from tab name
                document.querySelectorAll('[id^="time-container"]').forEach(el => el.style.display = 'none'); // Hide all time containers

                if (cycleData[id] !== undefined) {
                    document.getElementById(`time-container${id}`).style.display = 'block';
                    processAndShowData(`time-container${id}`, cycleData[id], ['chart1', 'chart2', 'chart3'], lmemData[id], id);
                }

                setTimeout(function() {
                    document.getElementById("rate-line-container").style.display = "none"
                    console.log("暂时性关闭展示")
                }, 100)
                if (document.getElementById("tiu_uarch_rate").checked) {
                    setTimeout(function() {
                        document.getElementById("rate-line-container").style.display = "block"
                    }, 200)
                }
                //check the checkboxes and update data if checked
                attachListeners(checkBoxes, id);
            }
        });

        const color_col = time_header.indexOf(time_header.includes("func_name") ? "func_name" : "func_type"); //index of the data to display the color in chart
        console.log("color_col:", color_col)
        const processAndShowData = (containerId, cycleData, chartIds, lmemRecord, num) => {
            setTimeout(() => {
                let chart = showDataInChart(containerId, time_header, cycleData, categories, filter_cols, color_col);
                if (chart) { // Only push when chart is not null
                    all_charts.push(chart);
                }
                if (lmemRecord.length == 0) {
                    document.querySelector(".config-localmem").style.display = "none";
                }
                hexPattern = /^[0-9A-Fa-f]+$/;
                if (hexPattern.test(lmemRecord)) {
                    let lmemRecord = processAddr(lmemRecord, num - 1);

                }
                //console.log("old record:", lmemRecord)
                //console.log("op_Record:", new_op_record)
                document.querySelector("#show_localmem").onchange = createShowFunc("lmem-container", lmem_partition, lmemRecord, "LOCAL MEM(Occupied)");
                document.querySelector("#show_data_table").onchange = function(e) {
                    let container_id = "data-list"
                    if (e.target.checked) {
                        showFilterDataTable(container_id, time_header, filtered_data, "Cycle Information", categories, categories.length > 3 ? 3 : 0)
                    } else {
                        document.getElementById(container_id).style = "display:none"
                    }
                }
                if (document.getElementById("show_data_table").checked) {
                    showFilterDataTable("data-list", time_header, cycleData, "Cycle Information", categories);
                }

                let tiu = cycleData.filter(item => item[0] === 0);
                let gdma = cycleData.filter(item => item[0] === 1);
                let sdma = cycleData.filter(item => item[0] === 2);

                if (tiu.length > 0) {
                    createRateLine(`rate-line-container`, tiu, 'TIU uArch Rate');
                }

                if (time_header.includes("func_name") && time_header.includes("func_type")) {
                    processAndGeneratePieChart(chartIds[0], tiu, time_header, "TIU");
                    processAndGeneratePieChart(chartIds[1], gdma, time_header, "GDMA");
                    processAndGeneratePieChart(chartIds[2], sdma, time_header, "SDMA");
                }
            }, 20);
        };

        let index = 0
        document.getElementById("tiu_uarch_rate").onclick = function() {
            if (index == 0) {
                document.getElementById("rate-line-container").style.display = "block"
                index = 1
            } else {
                document.getElementById("rate-line-container").style.display = "none"
                index = 0
            }
        }

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                let previousTab = document.querySelector('.bg-r');
                if (previousTab) previousTab.classList.remove('bg-r');
                tab.classList.add('bg-r');
            });
        });
    </script>

</body>

</html>
